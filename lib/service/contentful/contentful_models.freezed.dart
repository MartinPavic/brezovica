// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'contentful_models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

Sys _$SysFromJson(Map<String, dynamic> json) {
  return _Sys.fromJson(json);
}

/// @nodoc
class _$SysTearOff {
  const _$SysTearOff();

  _Sys call(
      {required String type,
      String? linkType,
      String? id,
      String? space,
      String? environment,
      String? contentType,
      int? revision,
      DateTime? createdAt,
      DateTime? updatedAt,
      String? locale}) {
    return _Sys(
      type: type,
      linkType: linkType,
      id: id,
      space: space,
      environment: environment,
      contentType: contentType,
      revision: revision,
      createdAt: createdAt,
      updatedAt: updatedAt,
      locale: locale,
    );
  }

  Sys fromJson(Map<String, Object?> json) {
    return Sys.fromJson(json);
  }
}

/// @nodoc
const $Sys = _$SysTearOff();

/// @nodoc
mixin _$Sys {
  String get type => throw _privateConstructorUsedError;
  String? get linkType => throw _privateConstructorUsedError;
  String? get id => throw _privateConstructorUsedError;
  String? get space => throw _privateConstructorUsedError;
  String? get environment => throw _privateConstructorUsedError;
  String? get contentType => throw _privateConstructorUsedError;
  int? get revision => throw _privateConstructorUsedError;
  DateTime? get createdAt => throw _privateConstructorUsedError;
  DateTime? get updatedAt => throw _privateConstructorUsedError;
  String? get locale => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SysCopyWith<Sys> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SysCopyWith<$Res> {
  factory $SysCopyWith(Sys value, $Res Function(Sys) then) =
      _$SysCopyWithImpl<$Res>;
  $Res call(
      {String type,
      String? linkType,
      String? id,
      String? space,
      String? environment,
      String? contentType,
      int? revision,
      DateTime? createdAt,
      DateTime? updatedAt,
      String? locale});
}

/// @nodoc
class _$SysCopyWithImpl<$Res> implements $SysCopyWith<$Res> {
  _$SysCopyWithImpl(this._value, this._then);

  final Sys _value;
  // ignore: unused_field
  final $Res Function(Sys) _then;

  @override
  $Res call({
    Object? type = freezed,
    Object? linkType = freezed,
    Object? id = freezed,
    Object? space = freezed,
    Object? environment = freezed,
    Object? contentType = freezed,
    Object? revision = freezed,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
    Object? locale = freezed,
  }) {
    return _then(_value.copyWith(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      linkType: linkType == freezed
          ? _value.linkType
          : linkType // ignore: cast_nullable_to_non_nullable
              as String?,
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      space: space == freezed
          ? _value.space
          : space // ignore: cast_nullable_to_non_nullable
              as String?,
      environment: environment == freezed
          ? _value.environment
          : environment // ignore: cast_nullable_to_non_nullable
              as String?,
      contentType: contentType == freezed
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
      revision: revision == freezed
          ? _value.revision
          : revision // ignore: cast_nullable_to_non_nullable
              as int?,
      createdAt: createdAt == freezed
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedAt: updatedAt == freezed
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      locale: locale == freezed
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$SysCopyWith<$Res> implements $SysCopyWith<$Res> {
  factory _$SysCopyWith(_Sys value, $Res Function(_Sys) then) =
      __$SysCopyWithImpl<$Res>;
  @override
  $Res call(
      {String type,
      String? linkType,
      String? id,
      String? space,
      String? environment,
      String? contentType,
      int? revision,
      DateTime? createdAt,
      DateTime? updatedAt,
      String? locale});
}

/// @nodoc
class __$SysCopyWithImpl<$Res> extends _$SysCopyWithImpl<$Res>
    implements _$SysCopyWith<$Res> {
  __$SysCopyWithImpl(_Sys _value, $Res Function(_Sys) _then)
      : super(_value, (v) => _then(v as _Sys));

  @override
  _Sys get _value => super._value as _Sys;

  @override
  $Res call({
    Object? type = freezed,
    Object? linkType = freezed,
    Object? id = freezed,
    Object? space = freezed,
    Object? environment = freezed,
    Object? contentType = freezed,
    Object? revision = freezed,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
    Object? locale = freezed,
  }) {
    return _then(_Sys(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      linkType: linkType == freezed
          ? _value.linkType
          : linkType // ignore: cast_nullable_to_non_nullable
              as String?,
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      space: space == freezed
          ? _value.space
          : space // ignore: cast_nullable_to_non_nullable
              as String?,
      environment: environment == freezed
          ? _value.environment
          : environment // ignore: cast_nullable_to_non_nullable
              as String?,
      contentType: contentType == freezed
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
      revision: revision == freezed
          ? _value.revision
          : revision // ignore: cast_nullable_to_non_nullable
              as int?,
      createdAt: createdAt == freezed
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedAt: updatedAt == freezed
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      locale: locale == freezed
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Sys implements _Sys {
  const _$_Sys(
      {required this.type,
      this.linkType,
      this.id,
      this.space,
      this.environment,
      this.contentType,
      this.revision,
      this.createdAt,
      this.updatedAt,
      this.locale});

  factory _$_Sys.fromJson(Map<String, dynamic> json) => _$$_SysFromJson(json);

  @override
  final String type;
  @override
  final String? linkType;
  @override
  final String? id;
  @override
  final String? space;
  @override
  final String? environment;
  @override
  final String? contentType;
  @override
  final int? revision;
  @override
  final DateTime? createdAt;
  @override
  final DateTime? updatedAt;
  @override
  final String? locale;

  @override
  String toString() {
    return 'Sys(type: $type, linkType: $linkType, id: $id, space: $space, environment: $environment, contentType: $contentType, revision: $revision, createdAt: $createdAt, updatedAt: $updatedAt, locale: $locale)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Sys &&
            const DeepCollectionEquality().equals(other.type, type) &&
            const DeepCollectionEquality().equals(other.linkType, linkType) &&
            const DeepCollectionEquality().equals(other.id, id) &&
            const DeepCollectionEquality().equals(other.space, space) &&
            const DeepCollectionEquality()
                .equals(other.environment, environment) &&
            const DeepCollectionEquality()
                .equals(other.contentType, contentType) &&
            const DeepCollectionEquality().equals(other.revision, revision) &&
            const DeepCollectionEquality().equals(other.createdAt, createdAt) &&
            const DeepCollectionEquality().equals(other.updatedAt, updatedAt) &&
            const DeepCollectionEquality().equals(other.locale, locale));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(type),
      const DeepCollectionEquality().hash(linkType),
      const DeepCollectionEquality().hash(id),
      const DeepCollectionEquality().hash(space),
      const DeepCollectionEquality().hash(environment),
      const DeepCollectionEquality().hash(contentType),
      const DeepCollectionEquality().hash(revision),
      const DeepCollectionEquality().hash(createdAt),
      const DeepCollectionEquality().hash(updatedAt),
      const DeepCollectionEquality().hash(locale));

  @JsonKey(ignore: true)
  @override
  _$SysCopyWith<_Sys> get copyWith =>
      __$SysCopyWithImpl<_Sys>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SysToJson(this);
  }
}

abstract class _Sys implements Sys {
  const factory _Sys(
      {required String type,
      String? linkType,
      String? id,
      String? space,
      String? environment,
      String? contentType,
      int? revision,
      DateTime? createdAt,
      DateTime? updatedAt,
      String? locale}) = _$_Sys;

  factory _Sys.fromJson(Map<String, dynamic> json) = _$_Sys.fromJson;

  @override
  String get type;
  @override
  String? get linkType;
  @override
  String? get id;
  @override
  String? get space;
  @override
  String? get environment;
  @override
  String? get contentType;
  @override
  int? get revision;
  @override
  DateTime? get createdAt;
  @override
  DateTime? get updatedAt;
  @override
  String? get locale;
  @override
  @JsonKey(ignore: true)
  _$SysCopyWith<_Sys> get copyWith => throw _privateConstructorUsedError;
}

AssetFields _$AssetFieldsFromJson(Map<String, dynamic> json) {
  return _AssetFields.fromJson(json);
}

/// @nodoc
class _$AssetFieldsTearOff {
  const _$AssetFieldsTearOff();

  _AssetFields call(
      {required String title, required FileFields file, String? description}) {
    return _AssetFields(
      title: title,
      file: file,
      description: description,
    );
  }

  AssetFields fromJson(Map<String, Object?> json) {
    return AssetFields.fromJson(json);
  }
}

/// @nodoc
const $AssetFields = _$AssetFieldsTearOff();

/// @nodoc
mixin _$AssetFields {
  String get title => throw _privateConstructorUsedError;
  FileFields get file => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssetFieldsCopyWith<AssetFields> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssetFieldsCopyWith<$Res> {
  factory $AssetFieldsCopyWith(
          AssetFields value, $Res Function(AssetFields) then) =
      _$AssetFieldsCopyWithImpl<$Res>;
  $Res call({String title, FileFields file, String? description});

  $FileFieldsCopyWith<$Res> get file;
}

/// @nodoc
class _$AssetFieldsCopyWithImpl<$Res> implements $AssetFieldsCopyWith<$Res> {
  _$AssetFieldsCopyWithImpl(this._value, this._then);

  final AssetFields _value;
  // ignore: unused_field
  final $Res Function(AssetFields) _then;

  @override
  $Res call({
    Object? title = freezed,
    Object? file = freezed,
    Object? description = freezed,
  }) {
    return _then(_value.copyWith(
      title: title == freezed
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      file: file == freezed
          ? _value.file
          : file // ignore: cast_nullable_to_non_nullable
              as FileFields,
      description: description == freezed
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }

  @override
  $FileFieldsCopyWith<$Res> get file {
    return $FileFieldsCopyWith<$Res>(_value.file, (value) {
      return _then(_value.copyWith(file: value));
    });
  }
}

/// @nodoc
abstract class _$AssetFieldsCopyWith<$Res>
    implements $AssetFieldsCopyWith<$Res> {
  factory _$AssetFieldsCopyWith(
          _AssetFields value, $Res Function(_AssetFields) then) =
      __$AssetFieldsCopyWithImpl<$Res>;
  @override
  $Res call({String title, FileFields file, String? description});

  @override
  $FileFieldsCopyWith<$Res> get file;
}

/// @nodoc
class __$AssetFieldsCopyWithImpl<$Res> extends _$AssetFieldsCopyWithImpl<$Res>
    implements _$AssetFieldsCopyWith<$Res> {
  __$AssetFieldsCopyWithImpl(
      _AssetFields _value, $Res Function(_AssetFields) _then)
      : super(_value, (v) => _then(v as _AssetFields));

  @override
  _AssetFields get _value => super._value as _AssetFields;

  @override
  $Res call({
    Object? title = freezed,
    Object? file = freezed,
    Object? description = freezed,
  }) {
    return _then(_AssetFields(
      title: title == freezed
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      file: file == freezed
          ? _value.file
          : file // ignore: cast_nullable_to_non_nullable
              as FileFields,
      description: description == freezed
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AssetFields implements _AssetFields {
  const _$_AssetFields(
      {required this.title, required this.file, this.description});

  factory _$_AssetFields.fromJson(Map<String, dynamic> json) =>
      _$$_AssetFieldsFromJson(json);

  @override
  final String title;
  @override
  final FileFields file;
  @override
  final String? description;

  @override
  String toString() {
    return 'AssetFields(title: $title, file: $file, description: $description)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AssetFields &&
            const DeepCollectionEquality().equals(other.title, title) &&
            const DeepCollectionEquality().equals(other.file, file) &&
            const DeepCollectionEquality()
                .equals(other.description, description));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(title),
      const DeepCollectionEquality().hash(file),
      const DeepCollectionEquality().hash(description));

  @JsonKey(ignore: true)
  @override
  _$AssetFieldsCopyWith<_AssetFields> get copyWith =>
      __$AssetFieldsCopyWithImpl<_AssetFields>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AssetFieldsToJson(this);
  }
}

abstract class _AssetFields implements AssetFields {
  const factory _AssetFields(
      {required String title,
      required FileFields file,
      String? description}) = _$_AssetFields;

  factory _AssetFields.fromJson(Map<String, dynamic> json) =
      _$_AssetFields.fromJson;

  @override
  String get title;
  @override
  FileFields get file;
  @override
  String? get description;
  @override
  @JsonKey(ignore: true)
  _$AssetFieldsCopyWith<_AssetFields> get copyWith =>
      throw _privateConstructorUsedError;
}

FileFields _$FileFieldsFromJson(Map<String, dynamic> json) {
  return _FileFields.fromJson(json);
}

/// @nodoc
class _$FileFieldsTearOff {
  const _$FileFieldsTearOff();

  _FileFields call(
      {required String contentType,
      required String fileName,
      required String url,
      required Object details}) {
    return _FileFields(
      contentType: contentType,
      fileName: fileName,
      url: url,
      details: details,
    );
  }

  FileFields fromJson(Map<String, Object?> json) {
    return FileFields.fromJson(json);
  }
}

/// @nodoc
const $FileFields = _$FileFieldsTearOff();

/// @nodoc
mixin _$FileFields {
  String get contentType => throw _privateConstructorUsedError;
  String get fileName => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;
  Object get details => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FileFieldsCopyWith<FileFields> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FileFieldsCopyWith<$Res> {
  factory $FileFieldsCopyWith(
          FileFields value, $Res Function(FileFields) then) =
      _$FileFieldsCopyWithImpl<$Res>;
  $Res call({String contentType, String fileName, String url, Object details});
}

/// @nodoc
class _$FileFieldsCopyWithImpl<$Res> implements $FileFieldsCopyWith<$Res> {
  _$FileFieldsCopyWithImpl(this._value, this._then);

  final FileFields _value;
  // ignore: unused_field
  final $Res Function(FileFields) _then;

  @override
  $Res call({
    Object? contentType = freezed,
    Object? fileName = freezed,
    Object? url = freezed,
    Object? details = freezed,
  }) {
    return _then(_value.copyWith(
      contentType: contentType == freezed
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String,
      fileName: fileName == freezed
          ? _value.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String,
      url: url == freezed
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      details: details == freezed
          ? _value.details
          : details // ignore: cast_nullable_to_non_nullable
              as Object,
    ));
  }
}

/// @nodoc
abstract class _$FileFieldsCopyWith<$Res> implements $FileFieldsCopyWith<$Res> {
  factory _$FileFieldsCopyWith(
          _FileFields value, $Res Function(_FileFields) then) =
      __$FileFieldsCopyWithImpl<$Res>;
  @override
  $Res call({String contentType, String fileName, String url, Object details});
}

/// @nodoc
class __$FileFieldsCopyWithImpl<$Res> extends _$FileFieldsCopyWithImpl<$Res>
    implements _$FileFieldsCopyWith<$Res> {
  __$FileFieldsCopyWithImpl(
      _FileFields _value, $Res Function(_FileFields) _then)
      : super(_value, (v) => _then(v as _FileFields));

  @override
  _FileFields get _value => super._value as _FileFields;

  @override
  $Res call({
    Object? contentType = freezed,
    Object? fileName = freezed,
    Object? url = freezed,
    Object? details = freezed,
  }) {
    return _then(_FileFields(
      contentType: contentType == freezed
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String,
      fileName: fileName == freezed
          ? _value.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String,
      url: url == freezed
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      details: details == freezed
          ? _value.details
          : details // ignore: cast_nullable_to_non_nullable
              as Object,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_FileFields implements _FileFields {
  const _$_FileFields(
      {required this.contentType,
      required this.fileName,
      required this.url,
      required this.details});

  factory _$_FileFields.fromJson(Map<String, dynamic> json) =>
      _$$_FileFieldsFromJson(json);

  @override
  final String contentType;
  @override
  final String fileName;
  @override
  final String url;
  @override
  final Object details;

  @override
  String toString() {
    return 'FileFields(contentType: $contentType, fileName: $fileName, url: $url, details: $details)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FileFields &&
            const DeepCollectionEquality()
                .equals(other.contentType, contentType) &&
            const DeepCollectionEquality().equals(other.fileName, fileName) &&
            const DeepCollectionEquality().equals(other.url, url) &&
            const DeepCollectionEquality().equals(other.details, details));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(contentType),
      const DeepCollectionEquality().hash(fileName),
      const DeepCollectionEquality().hash(url),
      const DeepCollectionEquality().hash(details));

  @JsonKey(ignore: true)
  @override
  _$FileFieldsCopyWith<_FileFields> get copyWith =>
      __$FileFieldsCopyWithImpl<_FileFields>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_FileFieldsToJson(this);
  }
}

abstract class _FileFields implements FileFields {
  const factory _FileFields(
      {required String contentType,
      required String fileName,
      required String url,
      required Object details}) = _$_FileFields;

  factory _FileFields.fromJson(Map<String, dynamic> json) =
      _$_FileFields.fromJson;

  @override
  String get contentType;
  @override
  String get fileName;
  @override
  String get url;
  @override
  Object get details;
  @override
  @JsonKey(ignore: true)
  _$FileFieldsCopyWith<_FileFields> get copyWith =>
      throw _privateConstructorUsedError;
}

Asset _$AssetFromJson(Map<String, dynamic> json) {
  return _Asset.fromJson(json);
}

/// @nodoc
class _$AssetTearOff {
  const _$AssetTearOff();

  _Asset call(
      {required Sys sys, required AssetFields fields, Object? metadata}) {
    return _Asset(
      sys: sys,
      fields: fields,
      metadata: metadata,
    );
  }

  Asset fromJson(Map<String, Object?> json) {
    return Asset.fromJson(json);
  }
}

/// @nodoc
const $Asset = _$AssetTearOff();

/// @nodoc
mixin _$Asset {
  Sys get sys => throw _privateConstructorUsedError;
  AssetFields get fields => throw _privateConstructorUsedError;
  Object? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssetCopyWith<Asset> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssetCopyWith<$Res> {
  factory $AssetCopyWith(Asset value, $Res Function(Asset) then) =
      _$AssetCopyWithImpl<$Res>;
  $Res call({Sys sys, AssetFields fields, Object? metadata});

  $SysCopyWith<$Res> get sys;
  $AssetFieldsCopyWith<$Res> get fields;
}

/// @nodoc
class _$AssetCopyWithImpl<$Res> implements $AssetCopyWith<$Res> {
  _$AssetCopyWithImpl(this._value, this._then);

  final Asset _value;
  // ignore: unused_field
  final $Res Function(Asset) _then;

  @override
  $Res call({
    Object? sys = freezed,
    Object? fields = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      sys: sys == freezed
          ? _value.sys
          : sys // ignore: cast_nullable_to_non_nullable
              as Sys,
      fields: fields == freezed
          ? _value.fields
          : fields // ignore: cast_nullable_to_non_nullable
              as AssetFields,
      metadata: metadata == freezed ? _value.metadata : metadata,
    ));
  }

  @override
  $SysCopyWith<$Res> get sys {
    return $SysCopyWith<$Res>(_value.sys, (value) {
      return _then(_value.copyWith(sys: value));
    });
  }

  @override
  $AssetFieldsCopyWith<$Res> get fields {
    return $AssetFieldsCopyWith<$Res>(_value.fields, (value) {
      return _then(_value.copyWith(fields: value));
    });
  }
}

/// @nodoc
abstract class _$AssetCopyWith<$Res> implements $AssetCopyWith<$Res> {
  factory _$AssetCopyWith(_Asset value, $Res Function(_Asset) then) =
      __$AssetCopyWithImpl<$Res>;
  @override
  $Res call({Sys sys, AssetFields fields, Object? metadata});

  @override
  $SysCopyWith<$Res> get sys;
  @override
  $AssetFieldsCopyWith<$Res> get fields;
}

/// @nodoc
class __$AssetCopyWithImpl<$Res> extends _$AssetCopyWithImpl<$Res>
    implements _$AssetCopyWith<$Res> {
  __$AssetCopyWithImpl(_Asset _value, $Res Function(_Asset) _then)
      : super(_value, (v) => _then(v as _Asset));

  @override
  _Asset get _value => super._value as _Asset;

  @override
  $Res call({
    Object? sys = freezed,
    Object? fields = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_Asset(
      sys: sys == freezed
          ? _value.sys
          : sys // ignore: cast_nullable_to_non_nullable
              as Sys,
      fields: fields == freezed
          ? _value.fields
          : fields // ignore: cast_nullable_to_non_nullable
              as AssetFields,
      metadata: metadata == freezed ? _value.metadata : metadata,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Asset implements _Asset {
  const _$_Asset({required this.sys, required this.fields, this.metadata});

  factory _$_Asset.fromJson(Map<String, dynamic> json) =>
      _$$_AssetFromJson(json);

  @override
  final Sys sys;
  @override
  final AssetFields fields;
  @override
  final Object? metadata;

  @override
  String toString() {
    return 'Asset(sys: $sys, fields: $fields, metadata: $metadata)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Asset &&
            const DeepCollectionEquality().equals(other.sys, sys) &&
            const DeepCollectionEquality().equals(other.fields, fields) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(sys),
      const DeepCollectionEquality().hash(fields),
      const DeepCollectionEquality().hash(metadata));

  @JsonKey(ignore: true)
  @override
  _$AssetCopyWith<_Asset> get copyWith =>
      __$AssetCopyWithImpl<_Asset>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AssetToJson(this);
  }
}

abstract class _Asset implements Asset {
  const factory _Asset(
      {required Sys sys,
      required AssetFields fields,
      Object? metadata}) = _$_Asset;

  factory _Asset.fromJson(Map<String, dynamic> json) = _$_Asset.fromJson;

  @override
  Sys get sys;
  @override
  AssetFields get fields;
  @override
  Object? get metadata;
  @override
  @JsonKey(ignore: true)
  _$AssetCopyWith<_Asset> get copyWith => throw _privateConstructorUsedError;
}

Includes _$IncludesFromJson(Map<String, dynamic> json) {
  return _Includes.fromJson(json);
}

/// @nodoc
class _$IncludesTearOff {
  const _$IncludesTearOff();

  _Includes call(
      {@JsonKey(name: 'Asset') List<Asset>? asset,
      @JsonKey(name: 'Entry') List<Entry>? entry}) {
    return _Includes(
      asset: asset,
      entry: entry,
    );
  }

  Includes fromJson(Map<String, Object?> json) {
    return Includes.fromJson(json);
  }
}

/// @nodoc
const $Includes = _$IncludesTearOff();

/// @nodoc
mixin _$Includes {
  @JsonKey(name: 'Asset')
  List<Asset>? get asset => throw _privateConstructorUsedError;
  @JsonKey(name: 'Entry')
  List<Entry>? get entry => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IncludesCopyWith<Includes> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IncludesCopyWith<$Res> {
  factory $IncludesCopyWith(Includes value, $Res Function(Includes) then) =
      _$IncludesCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(name: 'Asset') List<Asset>? asset,
      @JsonKey(name: 'Entry') List<Entry>? entry});
}

/// @nodoc
class _$IncludesCopyWithImpl<$Res> implements $IncludesCopyWith<$Res> {
  _$IncludesCopyWithImpl(this._value, this._then);

  final Includes _value;
  // ignore: unused_field
  final $Res Function(Includes) _then;

  @override
  $Res call({
    Object? asset = freezed,
    Object? entry = freezed,
  }) {
    return _then(_value.copyWith(
      asset: asset == freezed
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      entry: entry == freezed
          ? _value.entry
          : entry // ignore: cast_nullable_to_non_nullable
              as List<Entry>?,
    ));
  }
}

/// @nodoc
abstract class _$IncludesCopyWith<$Res> implements $IncludesCopyWith<$Res> {
  factory _$IncludesCopyWith(_Includes value, $Res Function(_Includes) then) =
      __$IncludesCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(name: 'Asset') List<Asset>? asset,
      @JsonKey(name: 'Entry') List<Entry>? entry});
}

/// @nodoc
class __$IncludesCopyWithImpl<$Res> extends _$IncludesCopyWithImpl<$Res>
    implements _$IncludesCopyWith<$Res> {
  __$IncludesCopyWithImpl(_Includes _value, $Res Function(_Includes) _then)
      : super(_value, (v) => _then(v as _Includes));

  @override
  _Includes get _value => super._value as _Includes;

  @override
  $Res call({
    Object? asset = freezed,
    Object? entry = freezed,
  }) {
    return _then(_Includes(
      asset: asset == freezed
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      entry: entry == freezed
          ? _value.entry
          : entry // ignore: cast_nullable_to_non_nullable
              as List<Entry>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Includes implements _Includes {
  const _$_Includes(
      {@JsonKey(name: 'Asset') this.asset, @JsonKey(name: 'Entry') this.entry});

  factory _$_Includes.fromJson(Map<String, dynamic> json) =>
      _$$_IncludesFromJson(json);

  @override
  @JsonKey(name: 'Asset')
  final List<Asset>? asset;
  @override
  @JsonKey(name: 'Entry')
  final List<Entry>? entry;

  @override
  String toString() {
    return 'Includes(asset: $asset, entry: $entry)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Includes &&
            const DeepCollectionEquality().equals(other.asset, asset) &&
            const DeepCollectionEquality().equals(other.entry, entry));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(asset),
      const DeepCollectionEquality().hash(entry));

  @JsonKey(ignore: true)
  @override
  _$IncludesCopyWith<_Includes> get copyWith =>
      __$IncludesCopyWithImpl<_Includes>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_IncludesToJson(this);
  }
}

abstract class _Includes implements Includes {
  const factory _Includes(
      {@JsonKey(name: 'Asset') List<Asset>? asset,
      @JsonKey(name: 'Entry') List<Entry>? entry}) = _$_Includes;

  factory _Includes.fromJson(Map<String, dynamic> json) = _$_Includes.fromJson;

  @override
  @JsonKey(name: 'Asset')
  List<Asset>? get asset;
  @override
  @JsonKey(name: 'Entry')
  List<Entry>? get entry;
  @override
  @JsonKey(ignore: true)
  _$IncludesCopyWith<_Includes> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$SearchParametersTearOff {
  const _$SearchParametersTearOff();

  _SearchParameters call(
      {@JsonKey(name: 'content_type') String? contentType,
      String? select,
      int? limit,
      int? skip,
      @JsonKey(name: 'mimetype_group') String? mimeTypeGroup}) {
    return _SearchParameters(
      contentType: contentType,
      select: select,
      limit: limit,
      skip: skip,
      mimeTypeGroup: mimeTypeGroup,
    );
  }
}

/// @nodoc
const $SearchParameters = _$SearchParametersTearOff();

/// @nodoc
mixin _$SearchParameters {
  @JsonKey(name: 'content_type')
  String? get contentType => throw _privateConstructorUsedError;
  String? get select => throw _privateConstructorUsedError;
  int? get limit => throw _privateConstructorUsedError;
  int? get skip => throw _privateConstructorUsedError;
  @JsonKey(name: 'mimetype_group')
  String? get mimeTypeGroup => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SearchParametersCopyWith<SearchParameters> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SearchParametersCopyWith<$Res> {
  factory $SearchParametersCopyWith(
          SearchParameters value, $Res Function(SearchParameters) then) =
      _$SearchParametersCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(name: 'content_type') String? contentType,
      String? select,
      int? limit,
      int? skip,
      @JsonKey(name: 'mimetype_group') String? mimeTypeGroup});
}

/// @nodoc
class _$SearchParametersCopyWithImpl<$Res>
    implements $SearchParametersCopyWith<$Res> {
  _$SearchParametersCopyWithImpl(this._value, this._then);

  final SearchParameters _value;
  // ignore: unused_field
  final $Res Function(SearchParameters) _then;

  @override
  $Res call({
    Object? contentType = freezed,
    Object? select = freezed,
    Object? limit = freezed,
    Object? skip = freezed,
    Object? mimeTypeGroup = freezed,
  }) {
    return _then(_value.copyWith(
      contentType: contentType == freezed
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
      select: select == freezed
          ? _value.select
          : select // ignore: cast_nullable_to_non_nullable
              as String?,
      limit: limit == freezed
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int?,
      skip: skip == freezed
          ? _value.skip
          : skip // ignore: cast_nullable_to_non_nullable
              as int?,
      mimeTypeGroup: mimeTypeGroup == freezed
          ? _value.mimeTypeGroup
          : mimeTypeGroup // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$SearchParametersCopyWith<$Res>
    implements $SearchParametersCopyWith<$Res> {
  factory _$SearchParametersCopyWith(
          _SearchParameters value, $Res Function(_SearchParameters) then) =
      __$SearchParametersCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(name: 'content_type') String? contentType,
      String? select,
      int? limit,
      int? skip,
      @JsonKey(name: 'mimetype_group') String? mimeTypeGroup});
}

/// @nodoc
class __$SearchParametersCopyWithImpl<$Res>
    extends _$SearchParametersCopyWithImpl<$Res>
    implements _$SearchParametersCopyWith<$Res> {
  __$SearchParametersCopyWithImpl(
      _SearchParameters _value, $Res Function(_SearchParameters) _then)
      : super(_value, (v) => _then(v as _SearchParameters));

  @override
  _SearchParameters get _value => super._value as _SearchParameters;

  @override
  $Res call({
    Object? contentType = freezed,
    Object? select = freezed,
    Object? limit = freezed,
    Object? skip = freezed,
    Object? mimeTypeGroup = freezed,
  }) {
    return _then(_SearchParameters(
      contentType: contentType == freezed
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
      select: select == freezed
          ? _value.select
          : select // ignore: cast_nullable_to_non_nullable
              as String?,
      limit: limit == freezed
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int?,
      skip: skip == freezed
          ? _value.skip
          : skip // ignore: cast_nullable_to_non_nullable
              as int?,
      mimeTypeGroup: mimeTypeGroup == freezed
          ? _value.mimeTypeGroup
          : mimeTypeGroup // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_SearchParameters implements _SearchParameters {
  const _$_SearchParameters(
      {@JsonKey(name: 'content_type') this.contentType,
      this.select,
      this.limit,
      this.skip,
      @JsonKey(name: 'mimetype_group') this.mimeTypeGroup});

  @override
  @JsonKey(name: 'content_type')
  final String? contentType;
  @override
  final String? select;
  @override
  final int? limit;
  @override
  final int? skip;
  @override
  @JsonKey(name: 'mimetype_group')
  final String? mimeTypeGroup;

  @override
  String toString() {
    return 'SearchParameters(contentType: $contentType, select: $select, limit: $limit, skip: $skip, mimeTypeGroup: $mimeTypeGroup)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SearchParameters &&
            const DeepCollectionEquality()
                .equals(other.contentType, contentType) &&
            const DeepCollectionEquality().equals(other.select, select) &&
            const DeepCollectionEquality().equals(other.limit, limit) &&
            const DeepCollectionEquality().equals(other.skip, skip) &&
            const DeepCollectionEquality()
                .equals(other.mimeTypeGroup, mimeTypeGroup));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(contentType),
      const DeepCollectionEquality().hash(select),
      const DeepCollectionEquality().hash(limit),
      const DeepCollectionEquality().hash(skip),
      const DeepCollectionEquality().hash(mimeTypeGroup));

  @JsonKey(ignore: true)
  @override
  _$SearchParametersCopyWith<_SearchParameters> get copyWith =>
      __$SearchParametersCopyWithImpl<_SearchParameters>(this, _$identity);
}

abstract class _SearchParameters implements SearchParameters {
  const factory _SearchParameters(
          {@JsonKey(name: 'content_type') String? contentType,
          String? select,
          int? limit,
          int? skip,
          @JsonKey(name: 'mimetype_group') String? mimeTypeGroup}) =
      _$_SearchParameters;

  @override
  @JsonKey(name: 'content_type')
  String? get contentType;
  @override
  String? get select;
  @override
  int? get limit;
  @override
  int? get skip;
  @override
  @JsonKey(name: 'mimetype_group')
  String? get mimeTypeGroup;
  @override
  @JsonKey(ignore: true)
  _$SearchParametersCopyWith<_SearchParameters> get copyWith =>
      throw _privateConstructorUsedError;
}
