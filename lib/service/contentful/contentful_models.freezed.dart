// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'contentful_models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

Sys _$SysFromJson(Map<String, dynamic> json) {
  return _Sys.fromJson(json);
}

/// @nodoc
class _$SysTearOff {
  const _$SysTearOff();

  _Sys call(
      {required String type,
      Option<String> linkType = const None(),
      Option<String> id = const None(),
      Option<Object> space = const None(),
      Option<Object> environment = const None(),
      Option<Object> contentType = const None(),
      Option<int> revision = const None(),
      Option<String> createdAt = const None(),
      Option<String> updatedAt = const None(),
      Option<String> locale = const None()}) {
    return _Sys(
      type: type,
      linkType: linkType,
      id: id,
      space: space,
      environment: environment,
      contentType: contentType,
      revision: revision,
      createdAt: createdAt,
      updatedAt: updatedAt,
      locale: locale,
    );
  }

  Sys fromJson(Map<String, Object?> json) {
    return Sys.fromJson(json);
  }
}

/// @nodoc
const $Sys = _$SysTearOff();

/// @nodoc
mixin _$Sys {
  String get type => throw _privateConstructorUsedError;
  Option<String> get linkType => throw _privateConstructorUsedError;
  Option<String> get id => throw _privateConstructorUsedError;
  Option<Object> get space => throw _privateConstructorUsedError;
  Option<Object> get environment => throw _privateConstructorUsedError;
  Option<Object> get contentType => throw _privateConstructorUsedError;
  Option<int> get revision => throw _privateConstructorUsedError;
  Option<String> get createdAt => throw _privateConstructorUsedError;
  Option<String> get updatedAt => throw _privateConstructorUsedError;
  Option<String> get locale => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SysCopyWith<Sys> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SysCopyWith<$Res> {
  factory $SysCopyWith(Sys value, $Res Function(Sys) then) =
      _$SysCopyWithImpl<$Res>;
  $Res call(
      {String type,
      Option<String> linkType,
      Option<String> id,
      Option<Object> space,
      Option<Object> environment,
      Option<Object> contentType,
      Option<int> revision,
      Option<String> createdAt,
      Option<String> updatedAt,
      Option<String> locale});
}

/// @nodoc
class _$SysCopyWithImpl<$Res> implements $SysCopyWith<$Res> {
  _$SysCopyWithImpl(this._value, this._then);

  final Sys _value;
  // ignore: unused_field
  final $Res Function(Sys) _then;

  @override
  $Res call({
    Object? type = freezed,
    Object? linkType = freezed,
    Object? id = freezed,
    Object? space = freezed,
    Object? environment = freezed,
    Object? contentType = freezed,
    Object? revision = freezed,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
    Object? locale = freezed,
  }) {
    return _then(_value.copyWith(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      linkType: linkType == freezed
          ? _value.linkType
          : linkType // ignore: cast_nullable_to_non_nullable
              as Option<String>,
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as Option<String>,
      space: space == freezed
          ? _value.space
          : space // ignore: cast_nullable_to_non_nullable
              as Option<Object>,
      environment: environment == freezed
          ? _value.environment
          : environment // ignore: cast_nullable_to_non_nullable
              as Option<Object>,
      contentType: contentType == freezed
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as Option<Object>,
      revision: revision == freezed
          ? _value.revision
          : revision // ignore: cast_nullable_to_non_nullable
              as Option<int>,
      createdAt: createdAt == freezed
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as Option<String>,
      updatedAt: updatedAt == freezed
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as Option<String>,
      locale: locale == freezed
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as Option<String>,
    ));
  }
}

/// @nodoc
abstract class _$SysCopyWith<$Res> implements $SysCopyWith<$Res> {
  factory _$SysCopyWith(_Sys value, $Res Function(_Sys) then) =
      __$SysCopyWithImpl<$Res>;
  @override
  $Res call(
      {String type,
      Option<String> linkType,
      Option<String> id,
      Option<Object> space,
      Option<Object> environment,
      Option<Object> contentType,
      Option<int> revision,
      Option<String> createdAt,
      Option<String> updatedAt,
      Option<String> locale});
}

/// @nodoc
class __$SysCopyWithImpl<$Res> extends _$SysCopyWithImpl<$Res>
    implements _$SysCopyWith<$Res> {
  __$SysCopyWithImpl(_Sys _value, $Res Function(_Sys) _then)
      : super(_value, (v) => _then(v as _Sys));

  @override
  _Sys get _value => super._value as _Sys;

  @override
  $Res call({
    Object? type = freezed,
    Object? linkType = freezed,
    Object? id = freezed,
    Object? space = freezed,
    Object? environment = freezed,
    Object? contentType = freezed,
    Object? revision = freezed,
    Object? createdAt = freezed,
    Object? updatedAt = freezed,
    Object? locale = freezed,
  }) {
    return _then(_Sys(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      linkType: linkType == freezed
          ? _value.linkType
          : linkType // ignore: cast_nullable_to_non_nullable
              as Option<String>,
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as Option<String>,
      space: space == freezed
          ? _value.space
          : space // ignore: cast_nullable_to_non_nullable
              as Option<Object>,
      environment: environment == freezed
          ? _value.environment
          : environment // ignore: cast_nullable_to_non_nullable
              as Option<Object>,
      contentType: contentType == freezed
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as Option<Object>,
      revision: revision == freezed
          ? _value.revision
          : revision // ignore: cast_nullable_to_non_nullable
              as Option<int>,
      createdAt: createdAt == freezed
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as Option<String>,
      updatedAt: updatedAt == freezed
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as Option<String>,
      locale: locale == freezed
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as Option<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Sys implements _Sys {
  const _$_Sys(
      {required this.type,
      this.linkType = const None(),
      this.id = const None(),
      this.space = const None(),
      this.environment = const None(),
      this.contentType = const None(),
      this.revision = const None(),
      this.createdAt = const None(),
      this.updatedAt = const None(),
      this.locale = const None()});

  factory _$_Sys.fromJson(Map<String, dynamic> json) => _$$_SysFromJson(json);

  @override
  final String type;
  @JsonKey()
  @override
  final Option<String> linkType;
  @JsonKey()
  @override
  final Option<String> id;
  @JsonKey()
  @override
  final Option<Object> space;
  @JsonKey()
  @override
  final Option<Object> environment;
  @JsonKey()
  @override
  final Option<Object> contentType;
  @JsonKey()
  @override
  final Option<int> revision;
  @JsonKey()
  @override
  final Option<String> createdAt;
  @JsonKey()
  @override
  final Option<String> updatedAt;
  @JsonKey()
  @override
  final Option<String> locale;

  @override
  String toString() {
    return 'Sys(type: $type, linkType: $linkType, id: $id, space: $space, environment: $environment, contentType: $contentType, revision: $revision, createdAt: $createdAt, updatedAt: $updatedAt, locale: $locale)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Sys &&
            const DeepCollectionEquality().equals(other.type, type) &&
            const DeepCollectionEquality().equals(other.linkType, linkType) &&
            const DeepCollectionEquality().equals(other.id, id) &&
            const DeepCollectionEquality().equals(other.space, space) &&
            const DeepCollectionEquality()
                .equals(other.environment, environment) &&
            const DeepCollectionEquality()
                .equals(other.contentType, contentType) &&
            const DeepCollectionEquality().equals(other.revision, revision) &&
            const DeepCollectionEquality().equals(other.createdAt, createdAt) &&
            const DeepCollectionEquality().equals(other.updatedAt, updatedAt) &&
            const DeepCollectionEquality().equals(other.locale, locale));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(type),
      const DeepCollectionEquality().hash(linkType),
      const DeepCollectionEquality().hash(id),
      const DeepCollectionEquality().hash(space),
      const DeepCollectionEquality().hash(environment),
      const DeepCollectionEquality().hash(contentType),
      const DeepCollectionEquality().hash(revision),
      const DeepCollectionEquality().hash(createdAt),
      const DeepCollectionEquality().hash(updatedAt),
      const DeepCollectionEquality().hash(locale));

  @JsonKey(ignore: true)
  @override
  _$SysCopyWith<_Sys> get copyWith =>
      __$SysCopyWithImpl<_Sys>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SysToJson(this);
  }
}

abstract class _Sys implements Sys {
  const factory _Sys(
      {required String type,
      Option<String> linkType,
      Option<String> id,
      Option<Object> space,
      Option<Object> environment,
      Option<Object> contentType,
      Option<int> revision,
      Option<String> createdAt,
      Option<String> updatedAt,
      Option<String> locale}) = _$_Sys;

  factory _Sys.fromJson(Map<String, dynamic> json) = _$_Sys.fromJson;

  @override
  String get type;
  @override
  Option<String> get linkType;
  @override
  Option<String> get id;
  @override
  Option<Object> get space;
  @override
  Option<Object> get environment;
  @override
  Option<Object> get contentType;
  @override
  Option<int> get revision;
  @override
  Option<String> get createdAt;
  @override
  Option<String> get updatedAt;
  @override
  Option<String> get locale;
  @override
  @JsonKey(ignore: true)
  _$SysCopyWith<_Sys> get copyWith => throw _privateConstructorUsedError;
}

AssetFields _$AssetFieldsFromJson(Map<String, dynamic> json) {
  return _AssetFields.fromJson(json);
}

/// @nodoc
class _$AssetFieldsTearOff {
  const _$AssetFieldsTearOff();

  _AssetFields call(
      {required String title,
      required FileFields file,
      Option<String> description = const None()}) {
    return _AssetFields(
      title: title,
      file: file,
      description: description,
    );
  }

  AssetFields fromJson(Map<String, Object?> json) {
    return AssetFields.fromJson(json);
  }
}

/// @nodoc
const $AssetFields = _$AssetFieldsTearOff();

/// @nodoc
mixin _$AssetFields {
  String get title => throw _privateConstructorUsedError;
  FileFields get file => throw _privateConstructorUsedError;
  Option<String> get description => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssetFieldsCopyWith<AssetFields> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssetFieldsCopyWith<$Res> {
  factory $AssetFieldsCopyWith(
          AssetFields value, $Res Function(AssetFields) then) =
      _$AssetFieldsCopyWithImpl<$Res>;
  $Res call({String title, FileFields file, Option<String> description});

  $FileFieldsCopyWith<$Res> get file;
}

/// @nodoc
class _$AssetFieldsCopyWithImpl<$Res> implements $AssetFieldsCopyWith<$Res> {
  _$AssetFieldsCopyWithImpl(this._value, this._then);

  final AssetFields _value;
  // ignore: unused_field
  final $Res Function(AssetFields) _then;

  @override
  $Res call({
    Object? title = freezed,
    Object? file = freezed,
    Object? description = freezed,
  }) {
    return _then(_value.copyWith(
      title: title == freezed
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      file: file == freezed
          ? _value.file
          : file // ignore: cast_nullable_to_non_nullable
              as FileFields,
      description: description == freezed
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Option<String>,
    ));
  }

  @override
  $FileFieldsCopyWith<$Res> get file {
    return $FileFieldsCopyWith<$Res>(_value.file, (value) {
      return _then(_value.copyWith(file: value));
    });
  }
}

/// @nodoc
abstract class _$AssetFieldsCopyWith<$Res>
    implements $AssetFieldsCopyWith<$Res> {
  factory _$AssetFieldsCopyWith(
          _AssetFields value, $Res Function(_AssetFields) then) =
      __$AssetFieldsCopyWithImpl<$Res>;
  @override
  $Res call({String title, FileFields file, Option<String> description});

  @override
  $FileFieldsCopyWith<$Res> get file;
}

/// @nodoc
class __$AssetFieldsCopyWithImpl<$Res> extends _$AssetFieldsCopyWithImpl<$Res>
    implements _$AssetFieldsCopyWith<$Res> {
  __$AssetFieldsCopyWithImpl(
      _AssetFields _value, $Res Function(_AssetFields) _then)
      : super(_value, (v) => _then(v as _AssetFields));

  @override
  _AssetFields get _value => super._value as _AssetFields;

  @override
  $Res call({
    Object? title = freezed,
    Object? file = freezed,
    Object? description = freezed,
  }) {
    return _then(_AssetFields(
      title: title == freezed
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      file: file == freezed
          ? _value.file
          : file // ignore: cast_nullable_to_non_nullable
              as FileFields,
      description: description == freezed
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as Option<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AssetFields implements _AssetFields {
  const _$_AssetFields(
      {required this.title,
      required this.file,
      this.description = const None()});

  factory _$_AssetFields.fromJson(Map<String, dynamic> json) =>
      _$$_AssetFieldsFromJson(json);

  @override
  final String title;
  @override
  final FileFields file;
  @JsonKey()
  @override
  final Option<String> description;

  @override
  String toString() {
    return 'AssetFields(title: $title, file: $file, description: $description)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AssetFields &&
            const DeepCollectionEquality().equals(other.title, title) &&
            const DeepCollectionEquality().equals(other.file, file) &&
            const DeepCollectionEquality()
                .equals(other.description, description));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(title),
      const DeepCollectionEquality().hash(file),
      const DeepCollectionEquality().hash(description));

  @JsonKey(ignore: true)
  @override
  _$AssetFieldsCopyWith<_AssetFields> get copyWith =>
      __$AssetFieldsCopyWithImpl<_AssetFields>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AssetFieldsToJson(this);
  }
}

abstract class _AssetFields implements AssetFields {
  const factory _AssetFields(
      {required String title,
      required FileFields file,
      Option<String> description}) = _$_AssetFields;

  factory _AssetFields.fromJson(Map<String, dynamic> json) =
      _$_AssetFields.fromJson;

  @override
  String get title;
  @override
  FileFields get file;
  @override
  Option<String> get description;
  @override
  @JsonKey(ignore: true)
  _$AssetFieldsCopyWith<_AssetFields> get copyWith =>
      throw _privateConstructorUsedError;
}

FileFields _$FileFieldsFromJson(Map<String, dynamic> json) {
  return _FileFields.fromJson(json);
}

/// @nodoc
class _$FileFieldsTearOff {
  const _$FileFieldsTearOff();

  _FileFields call(
      {required String contentType,
      required String fileName,
      required String url,
      required Object details}) {
    return _FileFields(
      contentType: contentType,
      fileName: fileName,
      url: url,
      details: details,
    );
  }

  FileFields fromJson(Map<String, Object?> json) {
    return FileFields.fromJson(json);
  }
}

/// @nodoc
const $FileFields = _$FileFieldsTearOff();

/// @nodoc
mixin _$FileFields {
  String get contentType => throw _privateConstructorUsedError;
  String get fileName => throw _privateConstructorUsedError;
  String get url => throw _privateConstructorUsedError;
  Object get details => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FileFieldsCopyWith<FileFields> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FileFieldsCopyWith<$Res> {
  factory $FileFieldsCopyWith(
          FileFields value, $Res Function(FileFields) then) =
      _$FileFieldsCopyWithImpl<$Res>;
  $Res call({String contentType, String fileName, String url, Object details});
}

/// @nodoc
class _$FileFieldsCopyWithImpl<$Res> implements $FileFieldsCopyWith<$Res> {
  _$FileFieldsCopyWithImpl(this._value, this._then);

  final FileFields _value;
  // ignore: unused_field
  final $Res Function(FileFields) _then;

  @override
  $Res call({
    Object? contentType = freezed,
    Object? fileName = freezed,
    Object? url = freezed,
    Object? details = freezed,
  }) {
    return _then(_value.copyWith(
      contentType: contentType == freezed
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String,
      fileName: fileName == freezed
          ? _value.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String,
      url: url == freezed
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      details: details == freezed
          ? _value.details
          : details // ignore: cast_nullable_to_non_nullable
              as Object,
    ));
  }
}

/// @nodoc
abstract class _$FileFieldsCopyWith<$Res> implements $FileFieldsCopyWith<$Res> {
  factory _$FileFieldsCopyWith(
          _FileFields value, $Res Function(_FileFields) then) =
      __$FileFieldsCopyWithImpl<$Res>;
  @override
  $Res call({String contentType, String fileName, String url, Object details});
}

/// @nodoc
class __$FileFieldsCopyWithImpl<$Res> extends _$FileFieldsCopyWithImpl<$Res>
    implements _$FileFieldsCopyWith<$Res> {
  __$FileFieldsCopyWithImpl(
      _FileFields _value, $Res Function(_FileFields) _then)
      : super(_value, (v) => _then(v as _FileFields));

  @override
  _FileFields get _value => super._value as _FileFields;

  @override
  $Res call({
    Object? contentType = freezed,
    Object? fileName = freezed,
    Object? url = freezed,
    Object? details = freezed,
  }) {
    return _then(_FileFields(
      contentType: contentType == freezed
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String,
      fileName: fileName == freezed
          ? _value.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String,
      url: url == freezed
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      details: details == freezed
          ? _value.details
          : details // ignore: cast_nullable_to_non_nullable
              as Object,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_FileFields implements _FileFields {
  const _$_FileFields(
      {required this.contentType,
      required this.fileName,
      required this.url,
      required this.details});

  factory _$_FileFields.fromJson(Map<String, dynamic> json) =>
      _$$_FileFieldsFromJson(json);

  @override
  final String contentType;
  @override
  final String fileName;
  @override
  final String url;
  @override
  final Object details;

  @override
  String toString() {
    return 'FileFields(contentType: $contentType, fileName: $fileName, url: $url, details: $details)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FileFields &&
            const DeepCollectionEquality()
                .equals(other.contentType, contentType) &&
            const DeepCollectionEquality().equals(other.fileName, fileName) &&
            const DeepCollectionEquality().equals(other.url, url) &&
            const DeepCollectionEquality().equals(other.details, details));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(contentType),
      const DeepCollectionEquality().hash(fileName),
      const DeepCollectionEquality().hash(url),
      const DeepCollectionEquality().hash(details));

  @JsonKey(ignore: true)
  @override
  _$FileFieldsCopyWith<_FileFields> get copyWith =>
      __$FileFieldsCopyWithImpl<_FileFields>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_FileFieldsToJson(this);
  }
}

abstract class _FileFields implements FileFields {
  const factory _FileFields(
      {required String contentType,
      required String fileName,
      required String url,
      required Object details}) = _$_FileFields;

  factory _FileFields.fromJson(Map<String, dynamic> json) =
      _$_FileFields.fromJson;

  @override
  String get contentType;
  @override
  String get fileName;
  @override
  String get url;
  @override
  Object get details;
  @override
  @JsonKey(ignore: true)
  _$FileFieldsCopyWith<_FileFields> get copyWith =>
      throw _privateConstructorUsedError;
}

Asset _$AssetFromJson(Map<String, dynamic> json) {
  return _Asset.fromJson(json);
}

/// @nodoc
class _$AssetTearOff {
  const _$AssetTearOff();

  _Asset call(
      {required Sys sys,
      required AssetFields fields,
      Option<Object> metadata = const None()}) {
    return _Asset(
      sys: sys,
      fields: fields,
      metadata: metadata,
    );
  }

  Asset fromJson(Map<String, Object?> json) {
    return Asset.fromJson(json);
  }
}

/// @nodoc
const $Asset = _$AssetTearOff();

/// @nodoc
mixin _$Asset {
  Sys get sys => throw _privateConstructorUsedError;
  AssetFields get fields => throw _privateConstructorUsedError;
  Option<Object> get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssetCopyWith<Asset> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssetCopyWith<$Res> {
  factory $AssetCopyWith(Asset value, $Res Function(Asset) then) =
      _$AssetCopyWithImpl<$Res>;
  $Res call({Sys sys, AssetFields fields, Option<Object> metadata});

  $SysCopyWith<$Res> get sys;
  $AssetFieldsCopyWith<$Res> get fields;
}

/// @nodoc
class _$AssetCopyWithImpl<$Res> implements $AssetCopyWith<$Res> {
  _$AssetCopyWithImpl(this._value, this._then);

  final Asset _value;
  // ignore: unused_field
  final $Res Function(Asset) _then;

  @override
  $Res call({
    Object? sys = freezed,
    Object? fields = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      sys: sys == freezed
          ? _value.sys
          : sys // ignore: cast_nullable_to_non_nullable
              as Sys,
      fields: fields == freezed
          ? _value.fields
          : fields // ignore: cast_nullable_to_non_nullable
              as AssetFields,
      metadata: metadata == freezed
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Option<Object>,
    ));
  }

  @override
  $SysCopyWith<$Res> get sys {
    return $SysCopyWith<$Res>(_value.sys, (value) {
      return _then(_value.copyWith(sys: value));
    });
  }

  @override
  $AssetFieldsCopyWith<$Res> get fields {
    return $AssetFieldsCopyWith<$Res>(_value.fields, (value) {
      return _then(_value.copyWith(fields: value));
    });
  }
}

/// @nodoc
abstract class _$AssetCopyWith<$Res> implements $AssetCopyWith<$Res> {
  factory _$AssetCopyWith(_Asset value, $Res Function(_Asset) then) =
      __$AssetCopyWithImpl<$Res>;
  @override
  $Res call({Sys sys, AssetFields fields, Option<Object> metadata});

  @override
  $SysCopyWith<$Res> get sys;
  @override
  $AssetFieldsCopyWith<$Res> get fields;
}

/// @nodoc
class __$AssetCopyWithImpl<$Res> extends _$AssetCopyWithImpl<$Res>
    implements _$AssetCopyWith<$Res> {
  __$AssetCopyWithImpl(_Asset _value, $Res Function(_Asset) _then)
      : super(_value, (v) => _then(v as _Asset));

  @override
  _Asset get _value => super._value as _Asset;

  @override
  $Res call({
    Object? sys = freezed,
    Object? fields = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_Asset(
      sys: sys == freezed
          ? _value.sys
          : sys // ignore: cast_nullable_to_non_nullable
              as Sys,
      fields: fields == freezed
          ? _value.fields
          : fields // ignore: cast_nullable_to_non_nullable
              as AssetFields,
      metadata: metadata == freezed
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Option<Object>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Asset implements _Asset {
  const _$_Asset(
      {required this.sys, required this.fields, this.metadata = const None()});

  factory _$_Asset.fromJson(Map<String, dynamic> json) =>
      _$$_AssetFromJson(json);

  @override
  final Sys sys;
  @override
  final AssetFields fields;
  @JsonKey()
  @override
  final Option<Object> metadata;

  @override
  String toString() {
    return 'Asset(sys: $sys, fields: $fields, metadata: $metadata)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Asset &&
            const DeepCollectionEquality().equals(other.sys, sys) &&
            const DeepCollectionEquality().equals(other.fields, fields) &&
            const DeepCollectionEquality().equals(other.metadata, metadata));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(sys),
      const DeepCollectionEquality().hash(fields),
      const DeepCollectionEquality().hash(metadata));

  @JsonKey(ignore: true)
  @override
  _$AssetCopyWith<_Asset> get copyWith =>
      __$AssetCopyWithImpl<_Asset>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AssetToJson(this);
  }
}

abstract class _Asset implements Asset {
  const factory _Asset(
      {required Sys sys,
      required AssetFields fields,
      Option<Object> metadata}) = _$_Asset;

  factory _Asset.fromJson(Map<String, dynamic> json) = _$_Asset.fromJson;

  @override
  Sys get sys;
  @override
  AssetFields get fields;
  @override
  Option<Object> get metadata;
  @override
  @JsonKey(ignore: true)
  _$AssetCopyWith<_Asset> get copyWith => throw _privateConstructorUsedError;
}

Includes _$IncludesFromJson(Map<String, dynamic> json) {
  return _Includes.fromJson(json);
}

/// @nodoc
class _$IncludesTearOff {
  const _$IncludesTearOff();

  _Includes call(
      {@JsonKey(name: 'Asset') Option<List<Asset>> assets = const None(),
      @JsonKey(name: 'Entry') Option<List<Entry>> entries = const None()}) {
    return _Includes(
      assets: assets,
      entries: entries,
    );
  }

  Includes fromJson(Map<String, Object?> json) {
    return Includes.fromJson(json);
  }
}

/// @nodoc
const $Includes = _$IncludesTearOff();

/// @nodoc
mixin _$Includes {
  @JsonKey(name: 'Asset')
  Option<List<Asset>> get assets => throw _privateConstructorUsedError;
  @JsonKey(name: 'Entry')
  Option<List<Entry>> get entries => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $IncludesCopyWith<Includes> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IncludesCopyWith<$Res> {
  factory $IncludesCopyWith(Includes value, $Res Function(Includes) then) =
      _$IncludesCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(name: 'Asset') Option<List<Asset>> assets,
      @JsonKey(name: 'Entry') Option<List<Entry>> entries});
}

/// @nodoc
class _$IncludesCopyWithImpl<$Res> implements $IncludesCopyWith<$Res> {
  _$IncludesCopyWithImpl(this._value, this._then);

  final Includes _value;
  // ignore: unused_field
  final $Res Function(Includes) _then;

  @override
  $Res call({
    Object? assets = freezed,
    Object? entries = freezed,
  }) {
    return _then(_value.copyWith(
      assets: assets == freezed
          ? _value.assets
          : assets // ignore: cast_nullable_to_non_nullable
              as Option<List<Asset>>,
      entries: entries == freezed
          ? _value.entries
          : entries // ignore: cast_nullable_to_non_nullable
              as Option<List<Entry>>,
    ));
  }
}

/// @nodoc
abstract class _$IncludesCopyWith<$Res> implements $IncludesCopyWith<$Res> {
  factory _$IncludesCopyWith(_Includes value, $Res Function(_Includes) then) =
      __$IncludesCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(name: 'Asset') Option<List<Asset>> assets,
      @JsonKey(name: 'Entry') Option<List<Entry>> entries});
}

/// @nodoc
class __$IncludesCopyWithImpl<$Res> extends _$IncludesCopyWithImpl<$Res>
    implements _$IncludesCopyWith<$Res> {
  __$IncludesCopyWithImpl(_Includes _value, $Res Function(_Includes) _then)
      : super(_value, (v) => _then(v as _Includes));

  @override
  _Includes get _value => super._value as _Includes;

  @override
  $Res call({
    Object? assets = freezed,
    Object? entries = freezed,
  }) {
    return _then(_Includes(
      assets: assets == freezed
          ? _value.assets
          : assets // ignore: cast_nullable_to_non_nullable
              as Option<List<Asset>>,
      entries: entries == freezed
          ? _value.entries
          : entries // ignore: cast_nullable_to_non_nullable
              as Option<List<Entry>>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
@OptionListAssetConverter()
class _$_Includes implements _Includes {
  const _$_Includes(
      {@JsonKey(name: 'Asset') this.assets = const None(),
      @JsonKey(name: 'Entry') this.entries = const None()});

  factory _$_Includes.fromJson(Map<String, dynamic> json) =>
      _$$_IncludesFromJson(json);

  @override
  @JsonKey(name: 'Asset')
  final Option<List<Asset>> assets;
  @override
  @JsonKey(name: 'Entry')
  final Option<List<Entry>> entries;

  @override
  String toString() {
    return 'Includes(assets: $assets, entries: $entries)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Includes &&
            const DeepCollectionEquality().equals(other.assets, assets) &&
            const DeepCollectionEquality().equals(other.entries, entries));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(assets),
      const DeepCollectionEquality().hash(entries));

  @JsonKey(ignore: true)
  @override
  _$IncludesCopyWith<_Includes> get copyWith =>
      __$IncludesCopyWithImpl<_Includes>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_IncludesToJson(this);
  }
}

abstract class _Includes implements Includes {
  const factory _Includes(
      {@JsonKey(name: 'Asset') Option<List<Asset>> assets,
      @JsonKey(name: 'Entry') Option<List<Entry>> entries}) = _$_Includes;

  factory _Includes.fromJson(Map<String, dynamic> json) = _$_Includes.fromJson;

  @override
  @JsonKey(name: 'Asset')
  Option<List<Asset>> get assets;
  @override
  @JsonKey(name: 'Entry')
  Option<List<Entry>> get entries;
  @override
  @JsonKey(ignore: true)
  _$IncludesCopyWith<_Includes> get copyWith =>
      throw _privateConstructorUsedError;
}

SearchParameters _$SearchParametersFromJson(Map<String, dynamic> json) {
  return _SearchParameters.fromJson(json);
}

/// @nodoc
class _$SearchParametersTearOff {
  const _$SearchParametersTearOff();

  _SearchParameters call(
      {@JsonKey(name: 'content_type')
          Option<String> contentType = const None(),
      Option<String> select = const None(),
      Option<int> limit = const None(),
      Option<int> skip = const None(),
      @JsonKey(name: 'mimetype_group')
          Option<String> mimeTypeGroup = const None()}) {
    return _SearchParameters(
      contentType: contentType,
      select: select,
      limit: limit,
      skip: skip,
      mimeTypeGroup: mimeTypeGroup,
    );
  }

  SearchParameters fromJson(Map<String, Object?> json) {
    return SearchParameters.fromJson(json);
  }
}

/// @nodoc
const $SearchParameters = _$SearchParametersTearOff();

/// @nodoc
mixin _$SearchParameters {
  @JsonKey(name: 'content_type')
  Option<String> get contentType => throw _privateConstructorUsedError;
  Option<String> get select => throw _privateConstructorUsedError;
  Option<int> get limit => throw _privateConstructorUsedError;
  Option<int> get skip => throw _privateConstructorUsedError;
  @JsonKey(name: 'mimetype_group')
  Option<String> get mimeTypeGroup => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SearchParametersCopyWith<SearchParameters> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SearchParametersCopyWith<$Res> {
  factory $SearchParametersCopyWith(
          SearchParameters value, $Res Function(SearchParameters) then) =
      _$SearchParametersCopyWithImpl<$Res>;
  $Res call(
      {@JsonKey(name: 'content_type') Option<String> contentType,
      Option<String> select,
      Option<int> limit,
      Option<int> skip,
      @JsonKey(name: 'mimetype_group') Option<String> mimeTypeGroup});
}

/// @nodoc
class _$SearchParametersCopyWithImpl<$Res>
    implements $SearchParametersCopyWith<$Res> {
  _$SearchParametersCopyWithImpl(this._value, this._then);

  final SearchParameters _value;
  // ignore: unused_field
  final $Res Function(SearchParameters) _then;

  @override
  $Res call({
    Object? contentType = freezed,
    Object? select = freezed,
    Object? limit = freezed,
    Object? skip = freezed,
    Object? mimeTypeGroup = freezed,
  }) {
    return _then(_value.copyWith(
      contentType: contentType == freezed
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as Option<String>,
      select: select == freezed
          ? _value.select
          : select // ignore: cast_nullable_to_non_nullable
              as Option<String>,
      limit: limit == freezed
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as Option<int>,
      skip: skip == freezed
          ? _value.skip
          : skip // ignore: cast_nullable_to_non_nullable
              as Option<int>,
      mimeTypeGroup: mimeTypeGroup == freezed
          ? _value.mimeTypeGroup
          : mimeTypeGroup // ignore: cast_nullable_to_non_nullable
              as Option<String>,
    ));
  }
}

/// @nodoc
abstract class _$SearchParametersCopyWith<$Res>
    implements $SearchParametersCopyWith<$Res> {
  factory _$SearchParametersCopyWith(
          _SearchParameters value, $Res Function(_SearchParameters) then) =
      __$SearchParametersCopyWithImpl<$Res>;
  @override
  $Res call(
      {@JsonKey(name: 'content_type') Option<String> contentType,
      Option<String> select,
      Option<int> limit,
      Option<int> skip,
      @JsonKey(name: 'mimetype_group') Option<String> mimeTypeGroup});
}

/// @nodoc
class __$SearchParametersCopyWithImpl<$Res>
    extends _$SearchParametersCopyWithImpl<$Res>
    implements _$SearchParametersCopyWith<$Res> {
  __$SearchParametersCopyWithImpl(
      _SearchParameters _value, $Res Function(_SearchParameters) _then)
      : super(_value, (v) => _then(v as _SearchParameters));

  @override
  _SearchParameters get _value => super._value as _SearchParameters;

  @override
  $Res call({
    Object? contentType = freezed,
    Object? select = freezed,
    Object? limit = freezed,
    Object? skip = freezed,
    Object? mimeTypeGroup = freezed,
  }) {
    return _then(_SearchParameters(
      contentType: contentType == freezed
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as Option<String>,
      select: select == freezed
          ? _value.select
          : select // ignore: cast_nullable_to_non_nullable
              as Option<String>,
      limit: limit == freezed
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as Option<int>,
      skip: skip == freezed
          ? _value.skip
          : skip // ignore: cast_nullable_to_non_nullable
              as Option<int>,
      mimeTypeGroup: mimeTypeGroup == freezed
          ? _value.mimeTypeGroup
          : mimeTypeGroup // ignore: cast_nullable_to_non_nullable
              as Option<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SearchParameters extends _SearchParameters {
  const _$_SearchParameters(
      {@JsonKey(name: 'content_type') this.contentType = const None(),
      this.select = const None(),
      this.limit = const None(),
      this.skip = const None(),
      @JsonKey(name: 'mimetype_group') this.mimeTypeGroup = const None()})
      : super._();

  factory _$_SearchParameters.fromJson(Map<String, dynamic> json) =>
      _$$_SearchParametersFromJson(json);

  @override
  @JsonKey(name: 'content_type')
  final Option<String> contentType;
  @JsonKey()
  @override
  final Option<String> select;
  @JsonKey()
  @override
  final Option<int> limit;
  @JsonKey()
  @override
  final Option<int> skip;
  @override
  @JsonKey(name: 'mimetype_group')
  final Option<String> mimeTypeGroup;

  @override
  String toString() {
    return 'SearchParameters(contentType: $contentType, select: $select, limit: $limit, skip: $skip, mimeTypeGroup: $mimeTypeGroup)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SearchParameters &&
            const DeepCollectionEquality()
                .equals(other.contentType, contentType) &&
            const DeepCollectionEquality().equals(other.select, select) &&
            const DeepCollectionEquality().equals(other.limit, limit) &&
            const DeepCollectionEquality().equals(other.skip, skip) &&
            const DeepCollectionEquality()
                .equals(other.mimeTypeGroup, mimeTypeGroup));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(contentType),
      const DeepCollectionEquality().hash(select),
      const DeepCollectionEquality().hash(limit),
      const DeepCollectionEquality().hash(skip),
      const DeepCollectionEquality().hash(mimeTypeGroup));

  @JsonKey(ignore: true)
  @override
  _$SearchParametersCopyWith<_SearchParameters> get copyWith =>
      __$SearchParametersCopyWithImpl<_SearchParameters>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SearchParametersToJson(this);
  }
}

abstract class _SearchParameters extends SearchParameters {
  const factory _SearchParameters(
          {@JsonKey(name: 'content_type') Option<String> contentType,
          Option<String> select,
          Option<int> limit,
          Option<int> skip,
          @JsonKey(name: 'mimetype_group') Option<String> mimeTypeGroup}) =
      _$_SearchParameters;
  const _SearchParameters._() : super._();

  factory _SearchParameters.fromJson(Map<String, dynamic> json) =
      _$_SearchParameters.fromJson;

  @override
  @JsonKey(name: 'content_type')
  Option<String> get contentType;
  @override
  Option<String> get select;
  @override
  Option<int> get limit;
  @override
  Option<int> get skip;
  @override
  @JsonKey(name: 'mimetype_group')
  Option<String> get mimeTypeGroup;
  @override
  @JsonKey(ignore: true)
  _$SearchParametersCopyWith<_SearchParameters> get copyWith =>
      throw _privateConstructorUsedError;
}

EntryFieldImage _$EntryFieldImageFromJson(Map<String, dynamic> json) {
  return _EntryFieldImage.fromJson(json);
}

/// @nodoc
class _$EntryFieldImageTearOff {
  const _$EntryFieldImageTearOff();

  _EntryFieldImage call(
      {required Sys sys, Option<Asset> asset = const None()}) {
    return _EntryFieldImage(
      sys: sys,
      asset: asset,
    );
  }

  EntryFieldImage fromJson(Map<String, Object?> json) {
    return EntryFieldImage.fromJson(json);
  }
}

/// @nodoc
const $EntryFieldImage = _$EntryFieldImageTearOff();

/// @nodoc
mixin _$EntryFieldImage {
  Sys get sys => throw _privateConstructorUsedError;
  Option<Asset> get asset => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EntryFieldImageCopyWith<EntryFieldImage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EntryFieldImageCopyWith<$Res> {
  factory $EntryFieldImageCopyWith(
          EntryFieldImage value, $Res Function(EntryFieldImage) then) =
      _$EntryFieldImageCopyWithImpl<$Res>;
  $Res call({Sys sys, Option<Asset> asset});

  $SysCopyWith<$Res> get sys;
}

/// @nodoc
class _$EntryFieldImageCopyWithImpl<$Res>
    implements $EntryFieldImageCopyWith<$Res> {
  _$EntryFieldImageCopyWithImpl(this._value, this._then);

  final EntryFieldImage _value;
  // ignore: unused_field
  final $Res Function(EntryFieldImage) _then;

  @override
  $Res call({
    Object? sys = freezed,
    Object? asset = freezed,
  }) {
    return _then(_value.copyWith(
      sys: sys == freezed
          ? _value.sys
          : sys // ignore: cast_nullable_to_non_nullable
              as Sys,
      asset: asset == freezed
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as Option<Asset>,
    ));
  }

  @override
  $SysCopyWith<$Res> get sys {
    return $SysCopyWith<$Res>(_value.sys, (value) {
      return _then(_value.copyWith(sys: value));
    });
  }
}

/// @nodoc
abstract class _$EntryFieldImageCopyWith<$Res>
    implements $EntryFieldImageCopyWith<$Res> {
  factory _$EntryFieldImageCopyWith(
          _EntryFieldImage value, $Res Function(_EntryFieldImage) then) =
      __$EntryFieldImageCopyWithImpl<$Res>;
  @override
  $Res call({Sys sys, Option<Asset> asset});

  @override
  $SysCopyWith<$Res> get sys;
}

/// @nodoc
class __$EntryFieldImageCopyWithImpl<$Res>
    extends _$EntryFieldImageCopyWithImpl<$Res>
    implements _$EntryFieldImageCopyWith<$Res> {
  __$EntryFieldImageCopyWithImpl(
      _EntryFieldImage _value, $Res Function(_EntryFieldImage) _then)
      : super(_value, (v) => _then(v as _EntryFieldImage));

  @override
  _EntryFieldImage get _value => super._value as _EntryFieldImage;

  @override
  $Res call({
    Object? sys = freezed,
    Object? asset = freezed,
  }) {
    return _then(_EntryFieldImage(
      sys: sys == freezed
          ? _value.sys
          : sys // ignore: cast_nullable_to_non_nullable
              as Sys,
      asset: asset == freezed
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as Option<Asset>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
@OptionAssetConverter()
class _$_EntryFieldImage implements _EntryFieldImage {
  const _$_EntryFieldImage({required this.sys, this.asset = const None()});

  factory _$_EntryFieldImage.fromJson(Map<String, dynamic> json) =>
      _$$_EntryFieldImageFromJson(json);

  @override
  final Sys sys;
  @JsonKey()
  @override
  final Option<Asset> asset;

  @override
  String toString() {
    return 'EntryFieldImage(sys: $sys, asset: $asset)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _EntryFieldImage &&
            const DeepCollectionEquality().equals(other.sys, sys) &&
            const DeepCollectionEquality().equals(other.asset, asset));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(sys),
      const DeepCollectionEquality().hash(asset));

  @JsonKey(ignore: true)
  @override
  _$EntryFieldImageCopyWith<_EntryFieldImage> get copyWith =>
      __$EntryFieldImageCopyWithImpl<_EntryFieldImage>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_EntryFieldImageToJson(this);
  }
}

abstract class _EntryFieldImage implements EntryFieldImage {
  const factory _EntryFieldImage({required Sys sys, Option<Asset> asset}) =
      _$_EntryFieldImage;

  factory _EntryFieldImage.fromJson(Map<String, dynamic> json) =
      _$_EntryFieldImage.fromJson;

  @override
  Sys get sys;
  @override
  Option<Asset> get asset;
  @override
  @JsonKey(ignore: true)
  _$EntryFieldImageCopyWith<_EntryFieldImage> get copyWith =>
      throw _privateConstructorUsedError;
}
